#include <stdio.h>
#include <signal.h>
#include <sys/stat.h>
#include <stdlib.h>
#include <sys/types.h>
#include <unistd.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <time.h> 
#include <math.h>
#include <sys/wait.h>

#define SERVERPID_FILENAME "serverpid.txt"
#define SHOWRESULT_FIFONAME "srfifo"
#define CLIENTNUMBER_FILE "clientnum.txt"
#define ALLPIDFILENAME "allpid.txt"
#define ALLFIFONAMESFILENAME "fifonames.txt"

#define FIFO_PERMS (S_IRUSR | S_IWUSR)

double shiftedInverseMatrix[40][40];
double convolutionMatrix[40][40];
double detArr[40][40];
double kernel[3][3];
//double determinant(double f[40][40],int x);


typedef struct package
{
	int pid;
	double result1;
	double result2;
	double timeLapsed1;
	double timeLapsed2;
}  showResultPackage_t;

void removeAllTxt();
void saveFifoName(char* name);
void savePid();

double determinant(double a[40][40], double k);

void cofactor(double num[40][40], double f);
void transpose(double num[40][40], double fac[40][40], double r);
void shiftedInverser(int n);

void convertConvMatris(int n, double conv[3][3]);
void resultOfCon(double conv[3][3], double source[40][40],double dest[40][40], int n);
int isInRange( int x1,int y1, int x2, int y2, int n);
void initKernel();

void killAllProcess();
void unlinkAllFifos();
//kill sinyali ulaşmazsa diye de kontrol, kernel düzelt
char lastCreatedClientLogFileName[20];


static void signalHandler(int signo) 
{
	FILE* fp;
	if(signo == SIGINT || signo == SIGTSTP)
	{
		fp = fopen(lastCreatedClientLogFileName,"a");
		fprintf(fp,"\n\n*************Ctrl^C or Ctrl^Z signal is receipted, program is terminating...*************\n\n");
		fclose(fp);
		killAllProcess();
		unlinkAllFifos();
		removeAllTxt();
		exit(0);
	}
	if(signo == SIGUSR2)
	{
		fp = fopen(lastCreatedClientLogFileName,"w");
		fprintf(fp,"\n\n*************Kill signal is receipted, program is terminating...*************\n\n");
		fclose(fp);

		exit(0);
	}
}

int main( int argc, char **argv )
{	
	int sizeOfMatris;
	char *mainPipeName;
	int fifoWrite;
	int fifoRead;
	int serverPid, childPid;
	char pidString[20];
	char childFifoName[20];
	int i,j;
	int num ;
	int status; //variable of waiting all child
	double orginalMatrisDet;	
	int numberOfClient;
	char logFileName[20];
	FILE *fp;
	time_t t1,t2;
	showResultPackage_t showResultPackage;
	
	
	
	if(argc != 2)
	{
		fprintf(stderr,"Usage: ./exe mainPipeName\n");
		exit(1);
	}
	
	mainPipeName = argv[1];
	
	srand(time(NULL));
	initKernel();
	struct sigaction sigact;
	sigact.sa_handler = signalHandler;
	sigact.sa_flags = 0;

	savePid();
	num = getpid() % 10;

	if ( (sigemptyset(&sigact.sa_mask) == -1) || (sigaction(SIGUSR1, &sigact, NULL) == -1) || 
		(sigaction(SIGINT, &sigact, NULL) == -1)  || (sigaction(SIGUSR2, &sigact, NULL) == -1)  || (sigaction(SIGTSTP, &sigact, NULL) == -1)) 
	{
		perror("Signal handler setting failed.");
		exit(1);
	}
	fp = fopen( SERVERPID_FILENAME, "r");
	fscanf(fp,"%d %d",&serverPid, &sizeOfMatris);
	fclose(fp);
	
	sprintf(pidString,"%d",getpid());
	
	saveFifoName(pidString);
	while(1)
	{	
		usleep(num*50000);



		fp = fopen( CLIENTNUMBER_FILE, "r");
		fscanf(fp,"%d",&numberOfClient);
		fclose(fp);
			
		kill(serverPid,SIGUSR1);
		sprintf(logFileName,"logs/sw%d.log",numberOfClient);
		sprintf(lastCreatedClientLogFileName,"%s",logFileName);
		
		
		fp = fopen( CLIENTNUMBER_FILE, "w");
		fprintf(fp,"%d",++numberOfClient);
		fclose(fp);

		if(mkfifo(pidString, FIFO_PERMS) == -1) 
		{
			fprintf(stderr,"Fifo creating error!\n");
			exit(1);
		}
		
		if( (fifoWrite=open(mainPipeName, O_WRONLY)) != -1 )
		{
	
			if(write(fifoWrite,pidString,sizeof(pidString)) < 0) 
			{
				perror("write error, client to server");
			}
			close(fifoWrite);
		
			if((fifoRead = open(pidString, O_RDONLY)) == -1 )
			{
				fprintf(stderr,"Error when opening the fifo!\n");
				exit(1);
			}

			read(fifoRead, detArr, sizeof(int)*1600);

			close(fifoRead);


			childPid = fork();
		
			if(childPid == 0)
			{
				savePid();
				shiftedInverser(sizeOfMatris);
				sprintf(childFifoName,"child%d",getppid());
				if(mkfifo(childFifoName, FIFO_PERMS) != -1) 
				{
				//	fprintf(stderr,"Fifo creating error!\n");
				//	exit(1);
				//}
			
				if( (fifoWrite=open(childFifoName, O_WRONLY)) == -1 )
				{
					fprintf(stderr,"Error when opening the fifo!aa_\n");
					exit(1);
				}
				if(write(fifoWrite,shiftedInverseMatrix,sizeof(int)*1600) < 0) 
				{
					perror("write error, client to server");
					exit(1);
				}
				close(fifoWrite);
				}
				exit(0);
			}
			else if(childPid > 0)
			{

				usleep(30000);
				sprintf(childFifoName,"child%d",getpid());
				saveFifoName(childFifoName);
				if( (fifoRead=open(childFifoName, O_RDONLY)) != -1 )
				{
					//fprintf(stderr,"aaError when opening the fifo!_\n");
					//exit(1);
				//}
				if(read(fifoRead,shiftedInverseMatrix,sizeof(int)*1600) < 0) 
				{
					perror("write error, client to server");
					exit(1);
				}
				close(fifoRead);
				unlink(childFifoName);
				}
			}
			else
			{
				perror("Fork error!");
				exit(1);
			}
			
			childPid = fork();
		
			if(childPid == 0)
			{
				savePid();
				convertConvMatris(sizeOfMatris,kernel);
				sprintf(childFifoName,"child%d",getppid());
				if(mkfifo(childFifoName, FIFO_PERMS) == -1) 
				{
					fprintf(stderr,"Fifo creating error!\n");
					exit(1);
				}
			
				if( (fifoWrite=open(childFifoName, O_WRONLY)) == -1 )
				{
					fprintf(stderr,"__Error when opening the fifo!\n");
					exit(1);
				}
				if(write(fifoWrite,convolutionMatrix,sizeof(int)*1600) < 0) 
				{
					perror("write error, client to server");
					exit(1);
				}
				close(fifoWrite);
			
				exit(0);
			}
			else if(childPid > 0)
			{
				usleep(30000);
				sprintf(childFifoName,"child%d",getpid());
				if( (fifoRead=open(childFifoName, O_RDONLY)) == -1 )
				{
					fprintf(stderr,"_____Error when opening the fifo!\n");
					exit(1);
				}
				if(read(fifoRead,convolutionMatrix,sizeof(int)*1600) < 0) 
				{
					perror("write error, client to server");
					exit(1);
				}
				close(fifoRead);
				unlink(childFifoName);
			} 
			else
			{
				perror("Fork error!");
				exit(1);
			}
			orginalMatrisDet = determinant(detArr,sizeOfMatris);
			showResultPackage.pid = getpid();
			t1 = clock();
			showResultPackage.result1 = orginalMatrisDet - determinant(shiftedInverseMatrix,sizeOfMatris);
			t2 = clock();
		
			showResultPackage.timeLapsed1 = ((int)(t2 - t1) / 1000000.0F ) * 1000;   
		
		
			t1 = clock();
			showResultPackage.result2 = orginalMatrisDet - determinant(convolutionMatrix,sizeOfMatris);
			t2 = clock();
		
			showResultPackage.timeLapsed2 = ((int)(t2 - t1) / 1000000.0F ) * 1000;   
		
		
			if( (fifoWrite=open(SHOWRESULT_FIFONAME, O_WRONLY)) != -1 )
			{
				write(fifoWrite,&showResultPackage,sizeof(showResultPackage_t));
				close(fifoWrite);
			}


			fp = fopen( logFileName, "w");
			fprintf(fp ,"Orginal Matrix=\n[");		
			for(i = 0; i < sizeOfMatris*2; ++i)
			{
				for(j = 0; j < sizeOfMatris*2 ; ++j)
				{
				 	fprintf(fp ,"%f ",detArr[i][j]);		
				}
				if(i+2 == sizeOfMatris*2)
					fprintf(fp ,"]\n");	
				else
					fprintf(fp ,"\n");	
			}
			fprintf(fp ,"\n");	
			fprintf(fp ,"Shifted Inverse Matrix=\n[");	
			for(i = 0; i < sizeOfMatris*2; ++i)
			{
				for(j = 0; j < sizeOfMatris*2 ; ++j)
				{
				 	fprintf(fp ,"%f ",shiftedInverseMatrix[i][j]);		
				}
				if(i+2 == sizeOfMatris*2)
					fprintf(fp ,"]\n");	
				else
					fprintf(fp ,"\n");
			}

			fprintf(fp ,"\n");
			fprintf(fp ,"Convolution Matrix=\n[");		
			for(i = 0; i < sizeOfMatris*2; ++i)
			{
				for(j = 0; j < sizeOfMatris*2 ; ++j)
				{
				 	fprintf(fp ,"%f ",convolutionMatrix[i][j]);		
				}
				if(i+2 == sizeOfMatris*2)
					fprintf(fp ,"]\n");	
				else
					fprintf(fp ,"\n");
			}

			fclose(fp);
		
		
			unlink(pidString);
		}
					
	}
	return 0;
}



void shiftedInverser(int n)
{
	double tempArr1[40][40];
	double tempArr2[40][40];
	double tempArr3[40][40];
	double tempArr4[40][40];

	int i,j;

	for(i = 0; i < n; ++i)
	{
		for(j = 0; j < n; ++j)
		{
			tempArr1[i][j] = detArr[i][j];
			tempArr2[i][j] = detArr[i][j+n];
			tempArr3[i][j] = detArr[i+n][j];
			tempArr4[i][j] = detArr[i+n][j+n];
		}	
	}
	cofactor(tempArr1,(double)n);
	cofactor(tempArr2,(double)n);
	cofactor(tempArr3,(double)n);
	cofactor(tempArr4,(double)n);
	
	for(i = 0; i < n; ++i)
	{
		for(j = 0; j < n; ++j)
		{
			shiftedInverseMatrix[i][j] = tempArr1[i][j];
			shiftedInverseMatrix[i][j+n] = tempArr2[i][j];
			shiftedInverseMatrix[i+n][j] = tempArr3[i][j];
			shiftedInverseMatrix[i+n][j+n] = tempArr4[i][j];
		}	
	}	
}

void convertConvMatris(int n, double conv[3][3])
{
	double tempArr1[40][40];
	double tempArr2[40][40];
	double tempArr3[40][40];
	double tempArr4[40][40];
	
	double tempArrResult1[40][40];
	double tempArrResult2[40][40];
	double tempArrResult3[40][40];
	double tempArrResult4[40][40];
	int i,j;

	for(i = 0; i < n; ++i)
	{
		for(j = 0; j < n; ++j)
		{
			tempArr1[i][j] = detArr[i][j];
			tempArr2[i][j] = detArr[i][j+n];
			tempArr3[i][j] = detArr[i+n][j];
			tempArr4[i][j] = detArr[i+n][j+n];
		}	
	}
	
	resultOfCon(conv, tempArr1, tempArrResult1, n);
	resultOfCon(conv, tempArr2, tempArrResult2, n);
	resultOfCon(conv, tempArr3, tempArrResult3, n);
	resultOfCon(conv, tempArr4, tempArrResult4, n);
	
	
	for(i = 0; i < n; ++i)
	{
		for(j = 0; j < n; ++j)
		{
			convolutionMatrix[i][j] = tempArrResult1[i][j];
			convolutionMatrix[i][j+n] = tempArrResult2[i][j];
			convolutionMatrix[i+n][j] = tempArrResult3[i][j];
			convolutionMatrix[i+n][j+n] = tempArrResult4[i][j];
		}	
	}	
}

void initKernel()
{
	kernel[0][0] = 1;
	kernel[0][1] = 0;
	kernel[0][2] = 0;
	kernel[1][0] = 0;
	kernel[1][1] = 1;
	kernel[1][2] = 0;
	kernel[2][0] = 0;
	kernel[2][1] = 0;
	kernel[2][2] = 1;
}
/*For calculating Determinant of the Matrix */
double determinant(double a[40][40], double k)
{
  double s = 1, det = 0, b[40][40];
  int i, j, m, n, c;
  if (k == 1)
    {
     return (a[0][0]);
    }
  else
    {
     det = 0;
     for (c = 0; c < k; c++)
       {
        m = 0;
        n = 0;
        for (i = 0;i < k; i++)
          {
            for (j = 0 ;j < k; j++)
              {
                b[i][j] = 0;
                if (i != 0 && j != c)
                 {
                   b[m][n] = a[i][j];
                   if (n < (k - 2))
                    n++;
                   else
                    {
                     n = 0;
                     m++;
                     }
                   }
               }
             }
          det = det + s * (a[0][c] * determinant(b, k - 1));
          s = -1 * s;
          }
    }
 
    return (det);
}
 
 
 
 
 
 
 

 
void resultOfCon(double conv[3][3], double source[40][40],double dest[40][40], int n)
{
	int row, col;
	int i,j;
	double sum;
	for ( row = 0; row < n; row++ ) 
	{ 
		for ( col = 0; col < n; col++ ) 
		{
			sum = 0.0 ;
			for ( i = -1; i <= 1; i++ ) 
			{
				for ( j = -1; j <= 1; j++ ) 
				{
					if(isInRange(row,col,i,j,n))
					{
						sum += source[i + row][j + col] * conv[i+1][j+1];
					}
				}
				
			}
			dest[row][col] = sum;
		}
	}

}
//x1 and y1 source matris cord, x2 and y2 conv. matris cord
int isInRange( int x1,int y1, int x2, int y2, int n)
{
	int sum1 = x1 + x2;
	int sum2 = y1 + y2;
	if(sum1 >= 0 && sum1 < n && sum2 >= 0 && sum2 < n )
		return 1;
	else
		return 0;
}
 
 
 
 
 
 
 
 
void cofactor(double num[40][40], double f)
{
 double b[40][40], fac[40][40];
 int p, q, m, n, i, j;
 for (q = 0;q < f; q++)
 {
   for (p = 0;p < f; p++)
    {
     m = 0;
     n = 0;
     for (i = 0;i < f; i++)
     {
       for (j = 0;j < f; j++)
        {
          if (i != q && j != p)
          {
            b[m][n] = num[i][j];
            if (n < (f - 2))
             n++;
            else
             {
               n = 0;
               m++;
               }
            }
        }
      }
      fac[q][p] = pow(-1, q + p) * determinant(b, f - 1);
    }
  }
  transpose(num, fac, f);
}
/*Finding transpose of matrix*/ 
void transpose(double num[40][40], double fac[40][40], double r)
{
  int i, j;
  double b[40][40], inverse[40][40], d;
 
  for (i = 0;i < r; i++)
    {
     for (j = 0;j < r; j++)
       {
         b[i][j] = fac[j][i];
        }
    }
  d = determinant(num, r);
  for (i = 0;i < r; i++)
    {
     for (j = 0;j < r; j++)
       {
        inverse[i][j] = b[i][j] / d;
        }
    }

 
   for (i = 0;i < r; i++)
    {
     for (j = 0;j < r; j++)
       {
         	num[i][j] = inverse[i][j];
        }
     }

}

void killAllProcess()
{
	int pid;
	FILE *fp = fopen(ALLPIDFILENAME,"r");
	while (fscanf(fp, "%d", &pid) != EOF) {
		if(pid != getpid())
		{
			kill(pid,SIGUSR2);
		}
	}
}
void savePid()
{
	FILE *fp = fopen(ALLPIDFILENAME,"a");
	fprintf(fp,"%d\n",getpid());
	fclose(fp);

}

void saveFifoName(char* name)
{
	FILE *fp = fopen(ALLFIFONAMESFILENAME,"a");
	fprintf(fp,"%s\n",name);
	fclose(fp);
}
void unlinkAllFifos()
{
	char fifoName[20];
	FILE *fp = fopen(ALLFIFONAMESFILENAME,"r");
	while (fscanf(fp, "%s", fifoName) != EOF) {
		unlink(fifoName);
	}
}

void removeAllTxt()
{
	remove(SERVERPID_FILENAME);
	remove(CLIENTNUMBER_FILE);
	remove(ALLPIDFILENAME);
	remove(ALLFIFONAMESFILENAME);
}

